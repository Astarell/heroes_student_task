# Итоговый проект | Алгоритмы и структуры данных
Проект Heroes посвящён разработке алгоритмов для пошаговой стратегии с боевой системой. В итоговом задании вам предстоит реализовать ключевые алгоритмы, которые отвечают за генерацию армии противника, симуляцию пошагового боя, определение доступных целей для атаки и поиск кратчайшего пути между юнитами.

## Метод generate интерфейса GeneratePreset
Реализован жадный алгоритм с пошаговым выбором на основе эффективности юнитов по следующему приоритету: <br>
1) Соотношение АТК/Стоимость <br>
2) Соотношение ОЗ/Стоимость <br>

По условию не более 11 юнитов одного типа и общая стоимость не превышает заданное количество поинтов.

Алгоритмическая сложность метода составляет <b>O(N × M)</b>, где:

- N - количество типов юнитов;
- M - итоговое количество юнитов в сгенерированной армии.

Внешний цикл выполняется M раз, так как на каждой итерации добавляется ровно один юнит.
На каждой итерации алгоритм:
- Проходит по всем N типам юнитов, чтобы найти наилучший по критерию эффективности;
- Для каждого типа выполняет константное число операций: проверка лимита (≤11), проверка бюджета, сравнение эффективности.

Трудоёмкость основной логики выбора = M × O(N) = O(N × M).

Генерация координат с проверкой уникальности - в худшем случае O(M), но на практике поле имеет фиксированный размер, а M ≤ 44, поэтому среднее время генерации - O(1).

## Метод simulate интерфейса SimulateBattle
В методе реализован раундовый симулятор боя на основе сортировки по инициативе, где она определяется значением базовой атаки юнита: чем выше атака — тем раньше ход.

Каждый раунд состоит из следующих шагов:
1) Сбор всех живых юнитов из обеих армий.
2) Сортировка их по убыванию АТК - формирует общую очередь ходов.
3) Последовательное выполнение ходов: каждый живой юнит выполняет атаку через свою программу.
4) Бой завершается, как только в одной из армий не остаётся живых юнитов.

По сути, жадно-итеративный алгоритм симуляции боя.

n — общее количество юнитов в обеих армиях в начале боя.<br>
R — количество раундов боя.

Анализ одной итерации (раунда):

1) Сбор живых юнитов: O(n) (проход по всем юнитам);
2) Сортировка: O(k log k), где k — число живых юнитов в текущем раунде (k ≤ n);
3) Выполнение ходов: O(k).

Поскольку k ≤ n, сложность одного раунда: O(n log n). <br>
В худшем случае за раунд умирает только один юнит, значит максимум R = n раундов.

Общая сложность: <b>O(n² log n)</b>.

## Метод getSuitableUnits интерфейса SuitableForAttackUnitsFinder
Реализован линейный алгоритм поиска крайнего элемента (минимума или максимума) с предварительной фильтрацией.

Особенности алгоритма:

1) Фильтрация по состоянию: из входных данных исключаются все мёртвые юниты.
2) Группировка по рядам: входные данные уже структурированы как List<List<Unit>>, где каждый подсписок представляет один ряд.<br>

Выбор крайнего юнита в каждом ряду:

- Если isLeftArmyTarget == true (атакуют армию компьютера, расположенную слева), выбирается юнит с максимальной координатой X, крайний правый в ряду (не прикрытый справа).
- Если isLeftArmyTarget == false (атакуют армию игрока, расположенную справа), выбирается юнит с минимальной координатой X, крайний левый в ряду (не прикрытый слева).

Отсутствие сортировки: алгоритм находит нужный юнит за один проход, используя приём поиска минимума/максимума.

N - общее количество юнитов во всех рядах.

1) Метод выполняет один полный проход по всем юнитам во всех рядах.
2) Для каждого юнита выполняются операции:
- Проверка isAlive() - O(1);
- Условное сравнение координаты x - O(1);
- Присваивание ссылки - O(1).

Итоговая сложность: <b>O(N)</b>, где N - общее число юнитов в армии противника.

## Метод getTargetPath интерфейса UnitTargetPathFinder
В методе реализован классический алгоритм A-star для поиска кратчайшего пути на сетке с препятствиями.

Компоненты алгоритма:

- Пространство поиска: прямоугольная сетка размером 27×21.
- Допустимые движения: 8 направлений (включая диагонали), что соответствует правилам перемещения юнитов.
- Препятствия: все клетки, занятые другими юнитами (из existingUnitList), кроме атакующего и цели.
- Эвристическая функция: используется Чебышёвское расстояние.
- Восстановление пути: после нахождения цели путь реконструируется.

Управление состоянием узлов: используются две структуры:

- openSet (приоритетная очередь) - узлы, которые нужно рассмотреть. <br>
- closedSet (хэш-множество) - уже обработанные узлы.

Операции и их сложность:

- Вставка и извлечение из PriorityQueue - O(log V).
- Проверка принадлежности к closedSet или obstacles - O(1).
- Поиск узла в openSet для обновления - O(V) из-за линейного перебора.

V = 567 - константа, поэтому общая сложность будет <b>O(V log V)</b>.
